# SophoDromos 0.2.0 Architecture Plan

## Executive Summary

This document outlines a comprehensive redesign of SophoDromos to achieve complete control over Maven test execution output in both single-module and multi-module projects. The new architecture will:

1. **Capture all test output** without allowing any to reach stdout during execution
2. **Track every lifecycle stage** with detailed logging in the format `<module>:<class>:<method>:<lifecycle-stage>`
3. **Provide unified handling** for both single-module and multi-module projects
4. **Leverage Maven reactor lifecycle hooks** for perfect coordination
5. **Ensure zero configuration** for end users

## Maven Reactor Lifecycle Overview

The Maven reactor provides extensive lifecycle hooks that we can leverage for perfect coordination. For a typical multi-module project:

```
1. Project Discovery Phase
   - Maven scans for all pom.xml files
   - Builds dependency graph between modules
   - Determines execution order
   → Hook: ExecutionListener.sessionStarted()

2. Reactor Build Order
   - Topologically sorts modules based on dependencies
   - Creates execution plan for all modules
   → Hook: ExecutionListener.projectDiscoveryStarted()

3. Lifecycle Execution (per module)
   - For each module in order:
     → Hook: ExecutionListener.projectStarted()
     a. validate → initialize → generate-sources → process-sources
     b. generate-resources → process-resources → compile → process-classes
     c. generate-test-sources → process-test-sources → generate-test-resources
     d. process-test-resources → test-compile → process-test-classes → test
        → Hook: ExecutionListener.mojoStarted() (for surefire:test)
        → Hook: ExecutionListener.mojoSucceeded/Failed() (for surefire:test)
     e. prepare-package → package → integration-test → verify → install
     → Hook: ExecutionListener.projectSucceeded/Failed()

4. Session Completion
   - Aggregates results from all modules
   - Reports final build status
   → Hook: ExecutionListener.sessionEnded()
```

### Maven Reactor Lifecycle Hooks Available

Maven provides these key extension points through `AbstractExecutionListener`:

```java
// Session-level hooks
public void sessionStarted(ExecutionEvent event)    // Entire reactor build starts
public void sessionEnded(ExecutionEvent event)      // Entire reactor build ends

// Project-level hooks (per module)
public void projectDiscoveryStarted(ExecutionEvent event)  // Module discovery
public void projectStarted(ExecutionEvent event)           // Module build starts
public void projectSucceeded(ExecutionEvent event)         // Module build succeeds
public void projectFailed(ExecutionEvent event)            // Module build fails
public void projectSkipped(ExecutionEvent event)           // Module build skipped

// Mojo-level hooks (per plugin execution)
public void mojoStarted(ExecutionEvent event)      // Plugin execution starts
public void mojoSucceeded(ExecutionEvent event)    // Plugin execution succeeds
public void mojoFailed(ExecutionEvent event)       // Plugin execution fails
public void mojoSkipped(ExecutionEvent event)      // Plugin execution skipped

// Fork-level hooks (for forked processes like Surefire)
public void forkStarted(ExecutionEvent event)      // Forked process starts
public void forkSucceeded(ExecutionEvent event)    // Forked process succeeds
public void forkFailed(ExecutionEvent event)       // Forked process fails
```

## Single-Module Test Lifecycle

For a traditional single-module project, the test lifecycle follows this sequence:

```
1. Test Discovery Phase
   ├── Maven Surefire Plugin Initialization
   ├── Classpath Resolution (test + main classes)
   ├── Test Class Discovery (via naming patterns)
   └── JUnit/TestNG Framework Detection

2. Test Preparation Phase
   ├── JVM Fork Preparation (if configured)
   ├── System Property Setup
   ├── Working Directory Setup
   └── Test Framework Initialization

3. Test Execution Phase
   ├── Framework Startup (JUnit/TestNG)
   ├── Test Class Loading and Validation
   ├── Before Suite/Class Hooks
   ├── For each test class:
   │   ├── Before Class Setup
   │   ├── For each test method:
   │   │   ├── Before Method Setup
   │   │   ├── Test Method Execution
   │   │   ├── Result Capture (pass/fail/skip)
   │   │   └── After Method Cleanup
   │   └── After Class Cleanup
   ├── After Suite/Class Hooks
   └── Framework Shutdown

4. Test Reporting Phase
   ├── Result Aggregation
   ├── XML Report Generation (target/surefire-reports)
   ├── Console Output Formatting
   └── Exit Code Determination
```

## Multi-Module Test Lifecycle

Multi-module projects execute the single-module lifecycle for each module in the reactor order:

```
1. Reactor Initialization
   ├── Multi-Module Discovery
   ├── Dependency Graph Construction
   ├── Execution Order Determination
   └── Session Property Setup

2. Per-Module Execution (repeated for each module)
   ├── Module Context Switch
   ├── Module-Specific Classpath Setup
   ├── Execute Single-Module Test Lifecycle (see above)
   ├── Module Result Capture
   └── Module Context Cleanup

3. Cross-Module Coordination
   ├── Shared Session State Management
   ├── Aggregated Progress Tracking
   ├── Cross-Module Dependency Validation
   └── Global Resource Management

4. Final Aggregation
   ├── All Module Results Collection
   ├── Global Summary Generation
   ├── Cross-Module Failure Analysis
   └── Final Exit Code Determination
```

## Plugin Project Plan for Complete Output Control

### Architecture Overview

The new architecture will use a **Test Execution Orchestrator** pattern that intercepts all test execution at the Maven plugin level and provides complete control over output and lifecycle tracking.

### Core Components

#### 1. Reactor Lifecycle Coordinator (NEW - Primary Controller)
```java
/**
 * Maven ExecutionListener that coordinates all reactor-level lifecycle events.
 * This is the primary control point that manages global state across all modules.
 */
@Component(role = AbstractExecutionListener.class, hint = "sophodromos")
public class SophoDromosReactorCoordinator extends AbstractExecutionListener {
    private final OutputCaptureManager outputCaptureManager;
    private final LifecycleTracker lifecycleTracker;
    private final ReactorSessionState sessionState;
    
    @Override
    public void sessionStarted(ExecutionEvent event) {
        // Initialize global output capture for entire reactor build
        outputCaptureManager.initializeGlobalCapture();
        sessionState.initializeSession(event.getSession());
        lifecycleTracker.trackEvent("none", "none", "none", REACTOR_SESSION_START);
    }
    
    @Override
    public void projectStarted(ExecutionEvent event) {
        String moduleId = getModuleId(event.getProject());
        sessionState.registerModuleStart(moduleId);
        lifecycleTracker.trackEvent(moduleId, "none", "none", REACTOR_PROJECT_START);
    }
    
    @Override
    public void mojoStarted(ExecutionEvent event) {
        if (isSophoDromosExecution(event)) {
            String moduleId = getModuleId(event.getProject());
            lifecycleTracker.trackEvent(moduleId, "none", "none", REACTOR_SOPHODROMOS_START);
            // Signal to SophoDromosTestMojo that global capture is active
            sessionState.setGlobalCaptureActive(true);
        }
    }
    
    @Override
    public void mojoSucceeded(ExecutionEvent event) {
        if (isSophoDromosExecution(event)) {
            String moduleId = getModuleId(event.getProject());
            lifecycleTracker.trackEvent(moduleId, "none", "none", REACTOR_SOPHODROMOS_SUCCESS);
            sessionState.registerModuleCompletion(moduleId);
        }
    }
    
    @Override
    public void projectSucceeded(ExecutionEvent event) {
        String moduleId = getModuleId(event.getProject());
        lifecycleTracker.trackEvent(moduleId, "none", "none", REACTOR_PROJECT_SUCCESS);
    }
    
    @Override
    public void sessionEnded(ExecutionEvent event) {
        // Release all captured output with final consolidated summary
        outputCaptureManager.releaseConsolidatedOutput(sessionState.getAllModuleResults());
        lifecycleTracker.trackEvent("none", "none", "none", REACTOR_SESSION_END);
        sessionState.cleanup();
    }
}
```

#### 2. Reactor Session State
```java
/**
 * Manages global state across the entire reactor session
 */
public class ReactorSessionState {
    private final Map<String, ModuleExecutionResult> moduleResults;
    private final AtomicBoolean globalCaptureActive;
    private final List<String> executionOrder;
    private volatile boolean isMultiModuleBuild;
    
    public void initializeSession(MavenSession session);
    public void registerModuleStart(String moduleId);
    public void registerModuleCompletion(String moduleId);
    public boolean isGlobalCaptureActive();
    public boolean isFirstModule(String moduleId);
    public boolean isLastModule(String moduleId);
    public List<ModuleExecutionResult> getAllModuleResults();
}
```

#### 3. Test Execution Orchestrator (Updated - Works with Reactor Coordinator)
```java
/**
 * Module-level controller that manages test execution within each module.
 * Now coordinates with ReactorCoordinator for global state management.
 */
public class TestExecutionOrchestrator {
    private final OutputCaptureManager outputManager;
    private final LifecycleTracker lifecycleTracker;
    private final ReactorSessionState sessionState;
    
    public TestExecutionResult executeTests(MavenProject project, MavenSession session) {
        String moduleId = getModuleId(project);
        
        // Check if we're in global capture mode (multi-module)
        if (sessionState.isGlobalCaptureActive()) {
            return executeWithGlobalCapture(project, session, moduleId);
        } else {
            return executeSingleModuleWithLocalCapture(project, session, moduleId);
        }
    }
    
    private TestExecutionResult executeWithGlobalCapture(
        MavenProject project, 
        MavenSession session, 
        String moduleId
    ) {
        // In global capture mode, all output is suppressed at module level
        // Only lifecycle events are emitted
        lifecycleTracker.trackEvent(moduleId, "none", "none", MODULE_TEST_START);
        
        // Execute tests with complete output suppression
        TestExecutionResult result = executeTestsWithSuppression(project);
        
        // Register results with global session state
        sessionState.addModuleResult(moduleId, result);
        
        lifecycleTracker.trackEvent(moduleId, "none", "none", MODULE_TEST_COMPLETE);
        return result;
    }
}
```

#### 4. Output Capture Manager (Enhanced for Reactor Coordination)
```java
/**
 * Manages output capture at both global (reactor) and local (module) levels.
 * In multi-module builds, operates in global mode with session-wide capture.
 */
public class OutputCaptureManager {
    private final PrintStream originalOut;
    private final PrintStream originalErr;
    private final GlobalCaptureBuffer globalBuffer;
    private final ThreadLocal<LocalCaptureBuffer> localBuffers;
    private volatile boolean globalCaptureActive;
    
    // Reactor-level methods (called by ReactorCoordinator)
    public void initializeGlobalCapture() {
        globalCaptureActive = true;
        System.setOut(new CapturingPrintStream(originalOut, globalBuffer));
        System.setErr(new CapturingPrintStream(originalErr, globalBuffer));
    }
    
    public void releaseConsolidatedOutput(List<ModuleExecutionResult> results) {
        // Restore original streams
        System.setOut(originalOut);
        System.setErr(originalErr);
        
        // Format and output consolidated results
        ConsolidatedOutputFormatter formatter = new ConsolidatedOutputFormatter();
        String finalOutput = formatter.format(results, globalBuffer.getEvents());
        originalOut.print(finalOutput);
        
        globalCaptureActive = false;
    }
    
    // Module-level methods (called by TestExecutionOrchestrator)
    public void startLocalCapture(String moduleId) {
        if (!globalCaptureActive) {
            LocalCaptureBuffer buffer = new LocalCaptureBuffer(moduleId);
            localBuffers.set(buffer);
            // Set up local capture streams
        }
    }
    
    public CapturedOutput getLocalCapturedOutput() {
        return localBuffers.get().getCapturedOutput();
    }
}

public class GlobalCaptureBuffer {
    private final ConcurrentLinkedQueue<ReactorEvent> events;
    private final Map<String, List<TestEvent>> moduleTestEvents;
    
    public void captureReactorEvent(ReactorEvent event);
    public void captureTestEvent(String moduleId, TestEvent event);
    public List<ReactorEvent> getReactorEvents();
    public Map<String, List<TestEvent>> getModuleTestEvents();
}

public class CapturingPrintStream extends PrintStream {
    private final PrintStream original;
    private final GlobalCaptureBuffer buffer;
    
    @Override
    public void println(String x) {
        // Capture to buffer instead of writing to original
        buffer.captureOutput(x, Thread.currentThread().getName());
        // Optionally write to original for debugging
        // original.println(x);
    }
}
```

#### 5. Lifecycle Tracker (Enhanced with Reactor Events)
```java
/**
 * Tracks every stage of test execution with detailed logging.
 * Now includes both reactor-level and test-level lifecycle events.
 */
public class LifecycleTracker {
    private final ReactorSessionState sessionState;
    private final OutputFormatter formatter;
    
    // Reactor-level event tracking
    public void trackEvent(String module, String testClass, String method, LifecycleStage stage) {
        LifecycleEvent event = new LifecycleEvent(module, testClass, method, stage, System.currentTimeMillis());
        
        // Always output lifecycle events immediately (they're never suppressed)
        String formattedEvent = formatter.formatLifecycleEvent(event);
        System.out.println(formattedEvent);  // This bypasses any capture if needed
        
        // Also store in session state for final reporting
        sessionState.addLifecycleEvent(event);
    }
    
    // Convenience methods for different levels
    public void trackReactorEvent(LifecycleStage stage) {
        trackEvent("none", "none", "none", stage);
    }
    
    public void trackModuleEvent(String module, LifecycleStage stage) {
        trackEvent(module, "none", "none", stage);
    }
    
    public void trackTestClassEvent(String module, String testClass, LifecycleStage stage) {
        trackEvent(module, testClass, "none", stage);
    }
    
    public void trackTestMethodEvent(String module, String testClass, String method, LifecycleStage stage) {
        trackEvent(module, testClass, method, stage);
    }
}

public enum LifecycleStage {
    // Reactor-level stages
    REACTOR_SESSION_START,
    REACTOR_PROJECT_START,
    REACTOR_SOPHODROMOS_START,
    REACTOR_SOPHODROMOS_SUCCESS,
    REACTOR_SOPHODROMOS_FAILED,
    REACTOR_PROJECT_SUCCESS,
    REACTOR_PROJECT_FAILED,
    REACTOR_SESSION_END,
    
    // Module-level stages
    MODULE_TEST_START,
    MODULE_TEST_DISCOVERY,
    MODULE_TEST_FRAMEWORK_INIT,
    MODULE_TEST_COMPLETE,
    
    // Test framework stages
    TEST_SUITE_START,
    TEST_CLASS_LOAD,
    TEST_CLASS_START,
    BEFORE_CLASS,
    TEST_METHOD_START,
    BEFORE_METHOD,
    TEST_EXECUTION,
    AFTER_METHOD,
    TEST_METHOD_COMPLETE,
    AFTER_CLASS,
    TEST_CLASS_COMPLETE,
    TEST_SUITE_COMPLETE
}

public class LifecycleEvent {
    private final String module;
    private final String testClass;
    private final String method;
    private final LifecycleStage stage;
    private final long timestamp;
    private final String threadName;
    
    // Constructor and getters...
}
```

#### 6. Updated SophoDromosTestMojo (Integration Point)
```java
/**
 * Updated main plugin entry point that integrates with the reactor coordinator.
 * Now acts as a local coordinator that defers to global state when available.
 */
@Mojo(name = "test", defaultPhase = LifecyclePhase.NONE, threadSafe = true)
public class SophoDromosTestMojo extends AbstractMojo {
    
    @Inject
    private ReactorSessionState sessionState;
    
    @Inject 
    private TestExecutionOrchestrator orchestrator;
    
    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (skipTests) {
            return;
        }
        
        // The ReactorCoordinator has already determined if we're in global capture mode
        TestExecutionResult result = orchestrator.executeTests(project, session);
        
        // In global capture mode, results are handled by ReactorCoordinator
        // In local mode, we handle them here as before
        if (!sessionState.isGlobalCaptureActive()) {
            handleLocalResults(result);
        }
        
        // Always check for failures (this can still fail the build)
        if (result.hasFailures()) {
            throw new MojoFailureException("Tests failed");
        }
    }
    
    private void handleLocalResults(TestExecutionResult result) {
        // Traditional single-module output handling
        displayHeader();
        displayModuleHeader();
        displayFormattedResults(result);
    }
}
```

#### 5. Test Framework Interceptors
```java
/**
 * Framework-specific interceptors that hook into JUnit/TestNG execution
 */
public class JUnitExecutionInterceptor implements TestExecutionListener {
    private final LifecycleTracker tracker;
    
    @Override
    public void testPlanExecutionStarted(TestPlan testPlan);
    
    @Override
    public void executionStarted(TestIdentifier testIdentifier);
    
    @Override
    public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult result);
}

public class TestNGExecutionInterceptor implements ITestListener {
    private final LifecycleTracker tracker;
    
    @Override
    public void onTestStart(ITestResult result);
    
    @Override
    public void onTestSuccess(ITestResult result);
    
    @Override
    public void onTestFailure(ITestResult result);
}
```

#### 6. Surefire Plugin Integration
```java
/**
 * Deep integration with Maven Surefire to intercept at the lowest level
 */
public class SurefirePluginInterceptor {
    private final TestExecutionOrchestrator orchestrator;
    
    public void interceptSurefireExecution(
        MavenProject project, 
        MavenSession session,
        SurefirePluginConfiguration config
    );
}
```

#### 7. Output Formatters
```java
/**
 * Formatters for different output modes
 */
public interface OutputFormatter {
    String formatLifecycleEvent(LifecycleEvent event);
    String formatTestResult(TestResult result);
    String formatSummary(ExecutionSummary summary);
}

public class LiveProgressFormatter implements OutputFormatter {
    @Override
    public String formatLifecycleEvent(LifecycleEvent event) {
        return String.format("%s:%s:%s:%s", 
            event.getModule(), 
            event.getTestClass(), 
            event.getMethod(), 
            event.getStage());
    }
}
```

### Implementation Strategy (Updated with Reactor Coordination)

#### Phase 1: Reactor Infrastructure Foundation
1. Implement `SophoDromosReactorCoordinator` as Maven ExecutionListener
2. Create `ReactorSessionState` for global state management  
3. Build `OutputCaptureManager` with global/local capture modes
4. Implement basic reactor lifecycle event tracking
5. Register ExecutionListener via Plexus components.xml

#### Phase 2: Enhanced Lifecycle Tracking
1. Create comprehensive `LifecycleTracker` with reactor + test events
2. Implement real-time lifecycle event output (format: `module:class:method:stage`)
3. Build event correlation between reactor and test framework events
4. Add thread-safe event logging with timestamps

#### Phase 3: Global Output Capture System
1. Implement `GlobalCaptureBuffer` for session-wide output capture
2. Create `CapturingPrintStream` to replace System.out/System.err
3. Build consolidated output formatting for final release
4. Implement complete output suppression during test execution

#### Phase 4: Test Framework Integration
1. Create JUnit 5 execution interceptor with lifecycle event integration
2. Create JUnit 4 execution interceptor with lifecycle event integration  
3. Create TestNG execution interceptor with lifecycle event integration
4. Implement framework detection and dynamic interceptor selection

#### Phase 5: Surefire Integration and Control
1. Deep integration with Maven Surefire plugin execution
2. Replace default test execution with our orchestrated execution
3. Capture all test framework output through our global system
4. Integrate with Maven's test reporting while maintaining our output control

## Single-Module Support as Special Case

The reactor-based architecture naturally supports single-module projects as a special case:

### Reactor Behavior for Single-Module Projects

```java
public class SophoDromosReactorCoordinator extends AbstractExecutionListener {
    
    @Override
    public void sessionStarted(ExecutionEvent event) {
        MavenSession session = event.getSession();
        boolean isMultiModule = session.getProjects().size() > 1;
        
        if (isMultiModule) {
            // Initialize global capture for multi-module build
            outputCaptureManager.initializeGlobalCapture();
            sessionState.initializeSession(session);
        } else {
            // For single-module, let individual module handle its own output
            sessionState.initializeSingleModuleSession(session);
        }
        
        lifecycleTracker.trackReactorEvent(REACTOR_SESSION_START);
    }
    
    @Override
    public void sessionEnded(ExecutionEvent event) {
        if (sessionState.isMultiModuleBuild()) {
            // Release consolidated output for multi-module
            outputCaptureManager.releaseConsolidatedOutput(sessionState.getAllModuleResults());
        }
        // For single-module, output was already handled by the module itself
        
        lifecycleTracker.trackReactorEvent(REACTOR_SESSION_END);
    }
}
```

### Single-Module Execution Flow

For single-module projects, the flow is:

1. **ReactorCoordinator.sessionStarted()** - Detects single-module, sets local mode
2. **ReactorCoordinator.projectStarted()** - Tracks single project start
3. **ReactorCoordinator.mojoStarted()** - Tracks SophoDromos execution start
4. **SophoDromosTestMojo.execute()** - Executes with local output (not suppressed)
5. **ReactorCoordinator.mojoSucceeded()** - Tracks SophoDromos execution completion
6. **ReactorCoordinator.projectSucceeded()** - Tracks single project completion
7. **ReactorCoordinator.sessionEnded()** - Session cleanup (no global output to release)

### Key Adaptations for Single-Module

- **No global output capture**: Single modules use traditional local output
- **Simplified lifecycle events**: Module name can be omitted or simplified
- **Immediate output**: No buffering or delayed output release
- **Traditional formatting**: Maintains backward compatibility with existing output formats

### Example Output Comparison

**Multi-Module Build:**
```
none:none:none:REACTOR_SESSION_START
api:none:none:REACTOR_PROJECT_START  
api:none:none:REACTOR_SOPHODROMOS_START
api:ApiTest:testMethod:TEST_EXECUTION
api:none:none:REACTOR_SOPHODROMOS_SUCCESS
core:none:none:REACTOR_PROJECT_START
core:CoreTest:testMethod:TEST_EXECUTION
...
[Final consolidated summary at the end]
```

**Single-Module Build:**
```
none:none:none:REACTOR_SESSION_START
myproject:none:none:REACTOR_PROJECT_START
myproject:none:none:REACTOR_SOPHODROMOS_START
myproject:MyTest:testMethod:TEST_EXECUTION
myproject:none:none:REACTOR_SOPHODROMOS_SUCCESS
none:none:none:REACTOR_SESSION_END

[Traditional immediate output with header and summary]
```

## Migration Plan

### Phase 1: Reactor Infrastructure Setup (Week 1-2)
```
1. Create new package structure:
   ├── io.github.clojang.sophodromos.reactor      (reactor coordination)
   ├── io.github.clojang.sophodromos.orchestration (test execution control)
   ├── io.github.clojang.sophodromos.capture      (output capture systems)
   ├── io.github.clojang.sophodromos.tracking     (lifecycle event tracking)
   └── io.github.clojang.sophodromos.formatting   (output formatting)

2. Implement reactor infrastructure:
   ├── SophoDromosReactorCoordinator (ExecutionListener)
   ├── ReactorSessionState (global state management)
   ├── LifecycleTracker (reactor + test event tracking)
   └── Update META-INF/plexus/components.xml for ExecutionListener registration

3. Basic integration:
   ├── Update SophoDromosTestMojo to inject ReactorSessionState
   ├── Implement basic reactor lifecycle event tracking
   └── Test reactor coordination with simple multi-module project
```

### Phase 2: Global Output Capture System (Week 3)
```
1. Implement global output capture infrastructure:
   ├── GlobalCaptureBuffer (session-wide output buffering)
   ├── CapturingPrintStream (System.out/System.err replacement)
   ├── Thread-safe capture with module correlation
   └── ConsolidatedOutputFormatter (final output generation)

2. Integrate capture with reactor coordinator:
   ├── Initialize global capture in sessionStarted()
   ├── Release consolidated output in sessionEnded()
   ├── Coordinate with ReactorSessionState
   └── Handle both multi-module and single-module modes

3. Enhanced lifecycle event tracking:
   ├── Real-time lifecycle event output (module:class:method:stage format)
   ├── Event correlation between reactor and test levels
   └── Thread-safe event logging with timestamps
```

### Phase 3: Test Execution Orchestration (Week 4)
```
1. Complete TestExecutionOrchestrator implementation:
   ├── Integration with ReactorSessionState for mode detection
   ├── Global capture mode execution (multi-module)
   ├── Local capture mode execution (single-module)
   └── Result aggregation and handoff to reactor coordinator

2. Deep Surefire integration:
   ├── Intercept Surefire plugin execution
   ├── Replace default test execution with orchestrated execution
   ├── Maintain compatibility with Surefire configuration
   └── Preserve Maven test reporting integration

3. Enhanced SophoDromosTestMojo:
   ├── Dependency injection of reactor components
   ├── Simplified execution logic (defer to orchestrator)
   ├── Maintain backward compatibility for configuration
   └── Proper error handling and build failure propagation
```

### Phase 4: Test Framework Integration (Week 5)
```
1. JUnit 5 Integration:
   ├── Implement TestExecutionListener with lifecycle event integration
   ├── Hook into test plan execution for detailed tracking
   ├── Capture test method lifecycle events with proper module correlation
   └── Extract test metadata and results for aggregation

2. JUnit 4 Integration:
   ├── Implement RunListener with lifecycle event integration
   ├── Hook into legacy test execution patterns
   ├── Handle JUnit 4 lifecycle events with module correlation
   └── Maintain backward compatibility for existing projects

3. TestNG Integration:
   ├── Implement ITestListener with lifecycle event integration
   ├── Hook into TestNG lifecycle and configuration methods
   ├── Handle TestNG-specific features (groups, parameters, etc.)
   └── Support TestNG configuration lifecycle events
```

### Phase 5: Complete Migration (Week 6)
```
1. Replace existing components:
   ├── Migrate from old TestOutputFormatter to new reactor-based system
   ├── Replace TestOutputCapture with ReactorCoordinator integration
   ├── Deprecate MultiModuleStateManager in favor of ReactorSessionState
   └── Remove old ExecutionListener (replace with ReactorCoordinator)

2. Update configuration and compatibility:
   ├── Maintain all existing configuration options and their behavior
   ├── Add new reactor-level configuration options
   ├── Ensure zero-breaking-change migration for users
   └── Create comprehensive migration documentation

3. Testing and validation:
   ├── Test with complex multi-module projects (Spring Boot, etc.)
   ├── Validate output formatting matches expected module:class:method:stage format
   ├── Performance testing to ensure minimal overhead
   └── Integration testing with different Maven versions and configurations
```

### Phase 6: Cleanup and Documentation (Week 7)
```
1. Code cleanup and optimization:
   ├── Remove all deprecated classes and methods
   ├── Optimize reactor coordination for performance
   ├── Clean up test fixtures and update test suite
   └── Final dependency updates and security review

2. Documentation and user experience:
   ├── Update README with new reactor-based architecture overview
   ├── Create detailed architectural documentation for contributors
   ├── Write user migration guide with examples
   └── Update plugin configuration documentation with lifecycle event options

3. Release preparation:
   ├── Version bump to 0.2.0 with proper semantic versioning
   ├── Comprehensive changelog with migration notes
   ├── Create release notes highlighting reactor coordination benefits
   └── Final integration testing and release candidate validation
```

## Current Project Structure

### Current `src/main/java` Structure

The current SophoDromos project has the following Java source structure:

```
src/main/java/
└── io/
    └── github/
        └── clojang/
            └── sophodromos/
                ├── HeaderFooterFormatter.java
                ├── MultiModuleStateManager.java
                ├── MultiModuleSummaryFormatter.java
                ├── OutputLineProcessor.java
                ├── OutputPatternMatcher.java
                ├── ProgressFormatter.java
                ├── SophoDromosExecutionListener.java
                ├── SophoDromosTestMojo.java
                ├── TestExecutionInterceptor.java
                ├── TestExecutionResult.java
                ├── TestOutputCapture.java
                ├── TestOutputFormatter.java
                ├── TestProcessManager.java
                └── TestResultFormatter.java
```

### Current Class Responsibilities

- **SophoDromosTestMojo**: Main Maven plugin entry point and execution controller
- **SophoDromosExecutionListener**: Maven ExecutionListener for multi-module coordination (current approach)
- **MultiModuleStateManager**: Manages state across modules in multi-module builds
- **MultiModuleSummaryFormatter**: Formats final summary for multi-module projects
- **TestExecutionInterceptor**: Intercepts test execution for output formatting
- **TestExecutionResult**: Data structure for test execution results
- **TestOutputCapture**: Captures and processes test output streams
- **TestOutputFormatter**: Primary output formatter for test results
- **TestProcessManager**: Manages Maven Surefire process execution
- **OutputPatternMatcher**: Pattern matching for test output lines
- **OutputLineProcessor**: Processes individual output lines
- **TestResultFormatter**: Formats individual test results
- **HeaderFooterFormatter**: Formats headers and footers
- **ProgressFormatter**: Formats progress indicators

## Proposed Project Structure

### Proposed `src/main/java` Structure

The new reactor-based architecture will reorganize the code into logical packages:

```
src/main/java/
└── io/
    └── github/
        └── clojang/
            └── sophodromos/
                ├── SophoDromosTestMojo.java                    (updated)
                │
                ├── reactor/
                │   ├── SophoDromosReactorCoordinator.java      (new - primary controller)
                │   ├── ReactorSessionState.java               (new - global state)
                │   └── ReactorLifecycleEvent.java              (new - event data)
                │
                ├── orchestration/
                │   ├── TestExecutionOrchestrator.java          (new - module controller)
                │   ├── SurefirePluginInterceptor.java          (new - surefire integration)
                │   └── TestFrameworkDetector.java              (new - framework detection)
                │
                ├── capture/
                │   ├── OutputCaptureManager.java               (new - global capture)
                │   ├── GlobalCaptureBuffer.java                (new - session-wide buffer)
                │   ├── LocalCaptureBuffer.java                 (new - module-local buffer)
                │   ├── CapturingPrintStream.java               (new - stream replacement)
                │   └── CapturedOutput.java                     (new - captured data)
                │
                ├── tracking/
                │   ├── LifecycleTracker.java                   (new - event tracking)
                │   ├── LifecycleEvent.java                     (new - event data)
                │   ├── LifecycleStage.java                     (new - stage enum)
                │   └── EventCorrelator.java                    (new - event correlation)
                │
                ├── formatting/
                │   ├── ConsolidatedOutputFormatter.java        (new - final output)
                │   ├── LiveProgressFormatter.java              (new - real-time events)
                │   ├── TestResultFormatter.java                (migrated)
                │   ├── HeaderFooterFormatter.java              (migrated)
                │   └── OutputFormatter.java                    (new - interface)
                │
                ├── integration/
                │   ├── junit5/
                │   │   ├── JUnit5ExecutionListener.java        (new)
                │   │   └── JUnit5TestInterceptor.java          (new)
                │   ├── junit4/
                │   │   ├── JUnit4RunListener.java              (new)
                │   │   └── JUnit4TestInterceptor.java          (new)
                │   └── testng/
                │       ├── TestNGExecutionListener.java       (new)
                │       └── TestNGTestInterceptor.java          (new)
                │
                └── legacy/
                    ├── TestExecutionInterceptor.java           (deprecated)
                    ├── TestExecutionResult.java                (migrated to capture)
                    ├── TestOutputCapture.java                  (deprecated)
                    ├── TestOutputFormatter.java                (deprecated)
                    ├── TestProcessManager.java                 (migrated to orchestration)
                    ├── OutputPatternMatcher.java               (deprecated)
                    ├── OutputLineProcessor.java                (deprecated)
                    ├── ProgressFormatter.java                  (deprecated)
                    ├── MultiModuleStateManager.java            (deprecated)
                    ├── MultiModuleSummaryFormatter.java        (deprecated)
                    └── SophoDromosExecutionListener.java       (deprecated)
```

### New Package Organization

#### `reactor/` - Reactor Coordination
- **SophoDromosReactorCoordinator**: Primary ExecutionListener controlling entire reactor lifecycle
- **ReactorSessionState**: Global state management across all modules in session
- **ReactorLifecycleEvent**: Data structures for reactor-level events

#### `orchestration/` - Test Execution Control  
- **TestExecutionOrchestrator**: Module-level test execution controller
- **SurefirePluginInterceptor**: Deep integration with Maven Surefire plugin
- **TestFrameworkDetector**: Automatic detection of JUnit/TestNG frameworks

#### `capture/` - Output Capture System
- **OutputCaptureManager**: Global and local output capture coordination
- **GlobalCaptureBuffer**: Session-wide output buffering for multi-module builds
- **LocalCaptureBuffer**: Module-local output buffering for single-module builds
- **CapturingPrintStream**: System.out/System.err replacement streams
- **CapturedOutput**: Data structures for captured output and events

#### `tracking/` - Lifecycle Event Tracking
- **LifecycleTracker**: Central lifecycle event tracking and logging
- **LifecycleEvent**: Data structure for lifecycle events with module:class:method:stage format
- **LifecycleStage**: Comprehensive enum of all reactor and test lifecycle stages
- **EventCorrelator**: Correlates events between reactor, module, and test framework levels

#### `formatting/` - Output Formatting
- **ConsolidatedOutputFormatter**: Final consolidated output for multi-module builds
- **LiveProgressFormatter**: Real-time lifecycle event formatting
- **OutputFormatter**: Common interface for all formatters
- **TestResultFormatter**: Individual test result formatting (migrated)
- **HeaderFooterFormatter**: Header and footer formatting (migrated)

#### `integration/` - Test Framework Integration
- **junit5/**: JUnit 5 specific integration classes
- **junit4/**: JUnit 4 specific integration classes  
- **testng/**: TestNG specific integration classes
- Each package contains framework-specific listeners and interceptors

#### `legacy/` - Deprecated Components
- Contains all current classes marked as deprecated during migration
- Maintains backward compatibility during transition period
- Will be removed in future version after migration completion

### Migration Benefits of New Structure

1. **Clear Separation of Concerns**: Each package has a specific responsibility
2. **Reactor-First Design**: Primary control through Maven reactor lifecycle
3. **Framework Extensibility**: Easy to add new test framework integrations
4. **Maintainable Architecture**: Logical organization makes code easier to understand and modify
5. **Migration Safety**: Legacy package preserves existing functionality during transition

## Expected Benefits

### Core Functionality
1. **Complete Output Control**: 100% capture of all test execution output through reactor-level coordination
2. **Perfect Multi-Module Coordination**: Eliminates all multi-module output coordination issues through reactor lifecycle hooks
3. **Detailed Lifecycle Tracking**: Full visibility into every stage of test execution with `module:class:method:stage` format
4. **Unified Architecture**: Single reactor-based codebase handles both single and multi-module projects seamlessly

### User Experience  
5. **Zero Configuration**: Works out of the box for all Maven project types without requiring extensions or special configuration
6. **Backward Compatibility**: All existing configuration options and output formats preserved
7. **Framework Agnostic**: Supports JUnit 4, JUnit 5, and TestNG with deep lifecycle integration
8. **Real-time Progress**: Live lifecycle event tracking provides immediate feedback during test execution

### Technical Excellence
9. **Performance Optimized**: Minimal overhead during test execution through efficient buffering and coordination
10. **Thread-Safe**: Proper concurrency handling for multi-threaded test execution
11. **Extensible Design**: Easy to add new formatters, output modes, and test framework integrations
12. **Robust Error Handling**: Graceful degradation and proper error propagation in all scenarios

## Risk Mitigation

### Technical Risks
1. **Reactor Integration Complexity**: The ExecutionListener registration and lifecycle coordination adds complexity
   - **Mitigation**: Comprehensive testing with different Maven versions and reactor scenarios
   - **Fallback**: Graceful degradation to single-module mode if reactor coordination fails

2. **Output Capture Reliability**: Global System.out/System.err replacement could interfere with other plugins
   - **Mitigation**: Careful stream management with proper restoration and error handling
   - **Fallback**: Detection of capture conflicts with automatic disable of global capture

3. **Performance Impact**: Additional lifecycle tracking and output buffering could slow builds
   - **Mitigation**: Efficient buffering, minimal overhead design, and performance benchmarking
   - **Fallback**: Configurable lifecycle event verbosity levels

### Compatibility Risks  
4. **Backward Compatibility**: New reactor-based architecture might break existing configurations
   - **Mitigation**: Maintain all existing configuration options and output format compatibility
   - **Testing**: Comprehensive regression testing with real-world projects

5. **Framework Coverage**: Deep integration with test frameworks could miss edge cases
   - **Mitigation**: Extensive testing with JUnit 4, JUnit 5, TestNG, and their various versions
   - **Fallback**: Framework detection with graceful fallback to basic output capture

### Project Risks
6. **Migration Complexity**: Large architectural changes could destabilize the existing codebase
   - **Mitigation**: Phased migration approach with continuous integration testing
   - **Safety**: Maintain deprecated code paths during transition period

7. **User Adoption**: Complex new architecture might confuse users or require configuration changes
   - **Mitigation**: Zero-configuration design with comprehensive documentation and examples
   - **Support**: Clear migration guide and backward compatibility guarantees